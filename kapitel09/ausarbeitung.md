# Systeme

**Autoren:** Danny Meihöfer - Bjarne Zaremba

## Lernziele für dieses Kapitel

Nach diesem Kapitel sollen folgende Aspekte klarer geworden sein:

- Was ist ein System?
- Was für Arten von Systemen gibt es?
- Was sind die Eigenschaften von Systemen?
- Was sind die Eigenschaften von Softwaresystemen?
- Aus was für Bausteinen bestehen Softwaresysteme?
- Was sind die Qualitätsmerkmale von Softwaresystemen?
- Was sind die Qualitätsmodelle von Softwaresystemen?
- Was sind die relevanten Qualitätsmerkmale im Detail?
- Was sind Metriken für die Qualität von Softwaresystemen?
- Was ist UML?
- Was sind die Diagrammtypen von UML?



## Was ist ein System?

Es gibt viele verschiedene Arten von Systemen. Dabei geht es nicht nur um Softwaresysteme. Auch die Natur, oder die Gesellschaft sind Systeme. Im folgenden werde ich ein paar unterschiedliche Arten von Systemen erklären.

### Sozioökonomische Systeme

Sozioökonomische Systeme sind Systeme, die sich mit dem Zusammenhang zwischen sozialem und wirtschaftlichem beschäftigen. Dabei geht es um die Wechselwirkungen zwischen den beiden Bereichen. Ein Beispiel für ein sozioökonomisches System ist die Gesellschaft. Die Gesellschaft ist ein System, welches sich aus vielen verschiedenen Teilsystemen zusammensetzt. Diese Teilsysteme sind zum Beispiel die Politik, die Wirtschaft, die Kultur, die Religion und die Wissenschaft. Diese Teilsysteme sind wiederum aus weiteren Teilsystemen zusammengesetzt. Die Wirtschaft besteht zum Beispiel aus den Bereichen Industrie, Handel, Banken und Versicherungen. Die Politik besteht aus den Bereichen Legislative, Exekutive und Judikative.

Generell bestehen Systeme aus mehreren Komponenten. Bei den sozioökonomischen Systemen gehören dazu unteranderem Soziale Strukturen, wie Institutionen, oder Organisationen. Als nächstes gehören Wirtschaftliche Aktivitäten dazu. Das sind zum Beispiel Produktion, Konsum, Verteilung und Tausch. Die letzten beiden Komponenten sind die Kulturellen Faktoren, wie Religionen, oder Traditionen und die Politischen Faktoren, wie Gesetze, oder Verfassungen.

Dabei muss man bedenken, dass sich die Komponenten gegenseitig beeinflussen sind. Sie sind also nicht komplett abgegrenzt von einander. Wird zum Beispiel eine neue Technologie erfunden kann sie einerseits dafür sorgen, dass die Wirtschaft wächst, andererseits kann sie aber auch dafür sorgen, dass die Gesellschaft sich verändert. 

Softwaresysteme haben die Chance die sozioökonomischen Systeme zu beeinflussen. Zum Beispiel kann ein Softwaresystem dafür sorgen, dass die Wirtschaft wächst, oder dass die Gesellschaft sich verändert.

### Technische Systeme

Die nächste Art von Systemen sind die technischen Systeme. Diese sind eine Verbindung aus mehreren technischen Komponenten wie Hardware, Software und Daten. Diese Komponenten können mit einander arbeiten um bestimmte Funktionen durchzuführen beziehungsweise, um bestimmte Probleme zu lösen.

In der Regel verarbeiten technische Systeme auf irgend eine Art und Weise Daten. Diese Daten können zum Beispiel von Sensoren kommen, oder von Menschen eingegeben werden. Die Daten werden dann von dem System verarbeitet. Diese Art von Systemen gibt es heutzutage überall in unserem Alltag. Beispiele dafür sind Computer, Smartphones, Autos, Energiesysteme und Verkehrsleitsysteme. Softwaresysteme sind auch technische Systeme.

### Soziale Systeme

Soziale Systeme basieren nur auf den Beziehungen zwischen mehreren sozialen Akteuren. Soziale Akteure können Personen, Gruppen, oder Organisationen sein. 

Jeder Akteur hat seine eigenen Ziele und Interessen und kann mit anderen Akteuren interagieren. Jeder von uns ist irgendwie ein Teil eines sozialen Systems. Wahrscheinlich sogar von ganz vielen. Zum Beispiel sind wir ein Teil der Familie, der Schule, der Universität, der Arbeit, der Freundegruppe, der Stadt, des Landes, der Religion und der Gesellschaft. In jedem diese sozialen Systeme können wir unterschiedliche Rollen haben und jede dieser Systeme kann ihre eigenen Werte und Normen haben. Deshalb kann sich das verhalten von uns in jedem dieser Systeme unterscheiden.

### Natürliche Systeme

Die natürlichen Systeme sind Systeme, die in der Natur vorkommen. Auch von diesen gibt es viele verschiedene Arten. Es gibt ganze Ökosysteme, wie zum Beispiel den Regenwald, oder die Wüste. Es gibt aber auch kleinere Systeme, wie zum Beispiel den menschlichen Körper. Alles was in der Natur vorkommt ist irgendwie ein natürliches System.

## Systemeigenschaften

Das waren jetzt ein paar Beispiele für unterschiedliche Arten von Systemen. Die Frage ist jetzt aber was macht ein System überhaupt aus? Was sind die Eigenschaften eines Systems?

Ein paar davon erklären wir jetzt.

### Komplizierte vs. Komplexe Systeme

Man kann Systeme als Kompliziert, oder Komplex bezeichnen. Oft werden diese begriffe Synonym verwendet, aber sie haben unterschiedliche Bedeutungen. 

Ein Kopmliziertes System ist schwer zu verstehen. Wie wenn man in der Schule ein kompliziertes Thema hat, dass man nur schwer lernen kann. Das wichtige dabei ist aber, dass die komplizierten Systeme trotzdem noch vorhersagbar sind. Wenn man sie also verstanden hat, kann man Probleme mit dem System auch lösen. Das verstehen erfordert zwar viel Aufwand, aber es ist möglich, da das Verhalten des Systems logisch nachvollziehbar ist. Ein Beispiel für so ein System sind Autos. Als Unwissender kann ist es sehr schwierig ein Auto zu bauen, oder nur ein Auto zu reparieren. Mit genug Wissen kann man es aber schaffen. Ein weiteres Beispiel ist ein Mischpult. Im ersten Moment sehen diese sehr überkompliziert aus, aber wenn man  einmal genug Erfahrung gesammelt hat kann man sie bedienen.

Komplexe Systeme sind im Gegensatz dazu unvorhersehbar. Das bedeutet, dass man selbst mit viel Wissen über ein System, nicht vorhersehen kann, was dieses macht. Ein Beispiel dafür ist das Wetter. Wir haben sehr viel Wissen über das Wetter, aber wir können es trotzdem nicht so richtig vorhersagen. Wir können zwar wahrscheinlichkeiten berechnen, aber wir können nicht genau sagen, was passieren wird. Den Zusammenhang zwischen Ursache und Wirkung kann man in diesen Systemen nicht so einfach nachvollziehen. Das liegt unter anderem daran, dass viele der Einflussfaktoren in einem System sich gegenseitig beeinflussen.

Manchmal wird komplex auch als die Steigerung von kompliziert verwendet. Das ist aber nicht ganz richtig. Komplex ist nicht die Steigerung von kompliziert, sondern eine andere Art von System.

### Adaptive Systeme

Adaptive Systeme zeichnen sich dadurch aus, dass sie sich an ihre Umgebung anpassen können. Das bedeutet, dass sie sich selbst verändern können, um besser mit ihrer Umgebung umgehen zu können. Ein Beispiel dafür ist der menschliche Körper. Wenn wir zum Beispiel Sport machen, dann passt sich unser Körper an. Er wird stärker und schneller. Wenn wir uns verletzen, dann heilt unser Körper die Wunde. Das ist auch eine Anpassung an die Umgebung.

Das bedeutet auch, dass ein System sich an die Umgebung neu anpassen kann, wenn sich die Umbegung selbst ändert. 

Für gewöhnlich sind diese Systeme von komplexer Natur. Diese Systeme sind oft dazu in der Lage durch ihre Erfahrungen zu lernen und sind deshalb nah an den lernenden Systemen.

Diese Art von Systemen ist auch in der Softwareentwicklung wichtig, weil sich die Anforderungen an ein System oft ändern kann.

### Lernende Systeme

Lernende Systeme sind Systeme, die sich selbst "verbessern" können. Sie können aus ihren Erfahrungen und aus Daten lernen. Für sie bedeutet das, sie müssen Informationen sammeln und verarbeiten. Verarbeiten heißt, sie analysieren die Informationen und erkennen darin muster und Zusammenhänge. Die Muster kann sich das System merken um später auf die Erfahrungen zurückgreifen zu können.

Ein Bereich der Softwareentwicklung ist das Machine Learning, das eng mit der künstlichen Intelligenz zusammenhängt. Ein Beispiel für ein lernendes System sind selbstfahrende Autos, oder Gesichtserkennungssoftware wie FaceID. Das System bekommt wird mit einer großen Menge an Daten gefüttert. In dem Fall viele Bilder von Gesichtern. Es erkennt dann Muster um bestimmen zu können welche Bilder ein Gesicht zeigen und welche nicht. Um so mehr Daten das System bekommt, um so besser wird es darin, Gesichter zu erkennen.

### Dynamische Systeme

Das besondere an dynamischen Systemen ist, dass sie sich über den Lauf der Zeit verändern können. Lernende und adaptive Systeme sind auch dynamisch, aber nicht jedes dynamische System ist auch lernend oder adaptiv. Die Eigenschaften von dynamischen Systemen können sich von selbst ändern.

Oft werden dynamische Systeme mit der Zeit komplexer. Sie werden oft mit Hilfe von mathematischen Gleichungen beschrieben. Ein Beispiel für ein dynamisches System ist das Wetter.

### Selektive Systeme

Selektive Systeme selektieren. Das bedeutet sie wählen bestimmte Informationen aus. Sie haben bestimmte Algorithmen die ihnen dabei helfen, die richtigen Informationen auszuwählen. Die kriterien nach denen sie auswählen können dabei sehr unterschiedlich sein und sich ständig ändern. Selektive Systeme werden zum Beispiel für Suchalgorithmen, oder Spamfilter verwendet. Eine Suchmaschine filtert aus einer großen Menge an Informationen die Informationen aus, die für den Nutzer relevant sind. Ein Spamfilter filtert aus einer großen Menge an zum Beispiel E-Mails die E-Mails, die Anzeichen von Spam haben, aus.

## Systemstrukturen

Was Systeme auszeichnet ist, dass sie aus mehreren Komponenten bestehen. Diese Komponenten können sich in unterschiedlichen Beziehungen zueinander befinden. Diese Beziehungen werden Systemstrukturen genannt. Es gibt viele unterschiedliche Arten von Systemstrukturen. Ein paar davon werden wir jetzt erklären.

Zum einen kann ein System an sich auch ein Teilsystem von einem anderen System sein, auch Subsystem genannt, oder auch anders herum kann ein System ein übergeordnetes System eines anderen Systems sein, auch Supersystem genannt. Ein Auto besteht zum Beispiel aus vielen kleineren eigenen Systemen, wie dem Motor und dem Getriebe. Das Auto ist aber auch ein Teil eines größeren Systems, nämlich der Verkehr.

Außerdem hat ein System oft Elemente für die Eingabe und die Ausgabe. Die Eingabe sind die Informationen, die in das System hineinfließen. Die Ausgabe sind die Informationen, die aus dem System herausfließen. Ein Beispiel dafür ist ein Computer. Die Eingabe sind die Daten, die wir eingeben, zum Beispiel mit der Tastatur. Die Ausgabe sind die Daten, die wir auf dem Bildschirm sehen. Diese Elemente werden auch Schnittstellen genannt.

Der Systemkontext beschreibt die Umgebung in der sich das System befindet und wie das System mit dieser interagiert. 

Ganz wichtig sind die Grenzen eines Systemes, auch der Scope genannt. Dafür muss man sich die Fragen stellen: 

- Was soll entwickelt werden?
- Welche anderen Systeme / Schnittstellen müssen berücksichtigt werden?
- Welche anderen Systeme / Schnittstellen müssen NICHT berücksichtigt werden?

Dann kann man klar bestimmen wo die Grenzen des Systems sind und was außerhalb des Systems liegt.

Auf den folgenden Abbildungen kann man die Struktur als Diagramm sehen.

![:scale 100%](media/syskon.PNG)

![:scale 100%](media/systemumgebung.png)

## Systemthinking

Beim Systemthinking handelt es sich um einen Denkansatz, der einem Hilft mit Systemen umzugehen. Es gibt verschiedene Fragen, Tools und Methoden, die einem dabei helfen können ein System zu verstehen und damit umzugehen. Gute Methoden zu haben ist wichtig wenn man komplexe Probleme innerhalb eines Systems lösen möchte. Im folgenden werde ich ein paar dieser Methoden erklären.


### Vernetzen

Die erste ist das **Vernetzen** beziehungsweise das identifizieren von Strukturen im System. Dieser Schritt ist für gewöhnlich der erste Schritt wenn man an einem System arbeiten möchte. Dabei gibt es verschiedene Fragen, die man sich stellen muss. Zum Beispiel:

- Welche Elemente gibt es?
- Wie sind die Elemente miteinander verbunden?
- Welche Beziehungen gibt es zwischen den Elementen?
- Welche Grenzen hat das System?
- Welche Elemente sind innerhalb des Systems?
- Welche Elemente sind außerhalb des Systems?
- Was für Einflussfaktoren gibt es?

Hat man diese Fragen beantwortet kann man sich ein Bild von dem System machen um es besser zu verstehen.

### Synthese und Analyse

Das nächste Werkzeug ist die **Synthese**. Die Synthese ist ein Prozess, bei dem aus mehreren einzelnen Elementen eine neues Element erzeugt wird. Das neue Element ist dabei mehr als die Summe seiner Teile. Es kann also mehr als die einzelnen Teile an sich. Es ist wichtig, dass man versteht, wie die einzelnen Teile zusammenarbeiten, um das neue Element zu erzeugen. Das Gegenstück zur Synthese ist die **Analyse**. Bei der Analyse wird ein Element in seine einzelnen Teile zerlegt. Das Ziel dabei ist es, die einzelnen Teile zu verstehen.

### Feedbackschleifen

Oft passiert es in Systemen, dass mehrere Elemente, die miteinander verbunden sind, sich gegenseitig beeinflussen. Dabei können auch Rückkopplungen zwischen den Elementen bestehen. Das bedeutet das eine Änderung von dem Element A das Element B beeinflusst. Die Änderung an B beeinflusst direkt wiederum das Element A. Dadurch entsteht ein Kreislauf, eine Schleife. Auch Feedbackschleife genannt. Diese Schleifen können positiv, oder negativ sein. Eine positive Feedbackschleife verstärkt die Änderung. Eine negative Feedbackschleife schwächt die Änderung ab.

Manche Feedbackschleifen sorgen dafür, dass sich ein System balanciert. Ein Beispiel dafür ist das Jäger und Beute System in der Natur, oder ein Thermostat. Diese balancieren sich immer selbst aus. Wenn es zu viele Beute gibt, führt das dazu, dass es mehr Jäger und weniger Beute gibt als zuvor. Wenn es zu viele Jäger gibt, dann gibt es auch weniger Beute. Das führt dazu, dass sich das System von selbst wieder ausbalanciert. Wenn es zu kalt ist, dann wird die Heizung angemacht. Wenn es zu warm ist, dann wird die Heizung ausgemacht.

Auf der anderen Seite gibt es unbalancierte Systeme, wie bei der Überfischung von gewässern. Wenn zu viel Fisch gefangen wird, dann gibt es weniger Fisch. Wenn es weniger Fisch gibt, dann wird mehr Fisch gefangen. Das führt dazu, dass es noch weniger Fisch gibt. Das System ist also nicht balanciert.

### Kausalität

Kausalität ist ein Begriff aus der Philosophie. Er beschreibt die Beziehung zwischen Ursache und Wirkung. Um Systeme und ihre Feedbackschleifen zu verstehen muss man die Kausalität verstehen. Was führt zu was?

Jedes Ereigniss hat irgendeine Ursache und jede Ursache ist die Wirkung eines anderen Ereignisses. Derjenige der das System verstehen will muss entschlüsseln welche Ereignisse zu welchen Wirkungen führen.

![:scale 60%](media/kaus.png)

### Systemabbildung

Die Sytemabbildung ist eine Schlüsseltechnik des Systemthinkings. Auch "mapping" genannt. Dabei wird ein System in eine andere in der Regel grafische Form gebracht. Das kann zum Beispiel ein Diagramm sein. Das Ziel dabei ist es, das System besser zu verstehen. Im Diagramm kann man dann relativ einfach die einzelnen Elemente und deren Beziehungen zu einander verstehen. Man kann natürlich auch nur Teilsysteme, oder einzelne Verhaltensweisen darstellen.

![:scale 100%](media/map.png)

# Softwaresysteme

Softwaresysteme sind Systeme, die mit Software realisiert werden. Sie unter anderem aus Softwarekomponenten, die mit einander interagieren können.

Es gibt verschiedene Arten von Softwaresystemen.

## Eingebettete Systeme

Die erste Art sind die eingebetteten Systeme. Die *Embedded Systems* sind spezielle Computersysteme die in andere Systeme eingebettet sind. Sie sind also ein Teil von einem anderen System. Sie sind oft auf eine bestimmte Aufgabe spezialisiert. Heutzutage kann man *embedded Systems* überall finden. In Autos, Waschmaschinen, Smartphones, oder Microcontrollern. In fast jedem elektronischem Gerät ist ein *embedded System* eingebaut.

## Intelligente Systeme

Intelligente Systeme sind Systeme, die selbstständig Probleme lösen können. Der wichtige Aspekt ist dabei, dass die Lösung der Probleme "intelligentes" Verhalten erfordern. Das bedeutet für das System, dass es rationale Entscheidungen treffen können muss. 

Oft können diese Systeme aus ihren Erfahrungen lernen und sich immer wieder anpassen. Beispiele für intelligente Systeme sind selbstfahrende Autos, künstliche Intelligenz und Autonome Systeme.

Die Grenzen zwischen intelligenten und "normalen" Softwaresystemen sind fließend, weil es keine fest gelegte Grenze da zwischen gibt.

## Informationssysteme

Informationssysteme sind Systeme, die Informationen verarbeiten. Sie sammeln, speichern, verarbeiten und verteilen Informationen. Sie sind primär nicht dazu da um die Informationen anderweitig zu verarbeiten.  Beispiele für Informationssysteme sind Datenbanken, Suchmaschinen, oder Mailserver. Sie alle speichern, oder verteilen Informationen. Heutzutage werden diese Art von Systemen immer wichtiger, weil durch die Digitalisierung immer mehr Informationen gesammelt werden. Jeder von uns hinterlässt im Internet Spuren, die von Informationssystemen gesammelt werden.

# Softwaresystembausteine

Ein Softwaresystem besteht aus mehreren Bausteinen. Jeder Baustein hat seine eigene Aufgabe.

Zum einen gibt es **Systeme** an sich. Sie erfüllen bestimmte Funktionen und können als **Subsysteme** in anderen größeren Systemen verwendet werden. Ein Beispiel dafür ist ein Betriebssystem. Es erfüllt bestimmte Funktionen und kann als Subsystem in anderen Softwaresystemen verwendet werden.

Dann gibt es **Module**. Module sind unabhängige Teile, die eine bestimmte Aufgabe erfüllen. Sie sind so konzipiert, dass sie in anderen Softwaresystemen wiederverwendet werden können. Man kann sie auch als eigenes kleines System betrachten.

**Pakete** sind Sammlungen von Modulen, die zusammengehören. Sie sind auch so konzipiert, dass sie in anderen Softwaresystemen wiederverwendet werden können. Ein Beispiel dafür ist die Java Standardbibliothek. Sie ist eine Sammlung von Paketen, die in anderen Java Programmen verwendet werden können.

**Klassen** sind Sammlungen von **Objekten**, die zusammengehören. Eine Klasse kann man als Schablone für ein Objekt betrachten. Ein Objekt ist eine Instanz einer Klasse. Ein Beispiel dafür ist eine Klasse Auto. Ein Auto hat bestimmte Eigenschaften, wie zum Beispiel die Farbe, die Marke, das Modell und das Baujahr. Ein Objekt ist dann ein bestimmtes Auto, zum Beispiel ein roter BMW 3er aus dem Jahr 2015.

**Interfaces** sind Schnittstellen, die die Kommunikationen zwischen verschiedenen Komponenten, oder Klassen ermöglichen. 

**Funktionen** sind Teile von einem Programm, die eine bestimmte Aufgabe erfüllen. Sie sind oft in Module, oder Klassen eingebettet.

## Qualitätsmermale von Softwaresystemen

Wenn man ein Softwaresystem erstellt, oder betrachtet muss man sich auch mit der Frage beschäftigen, ob das Softwaresystem gut ist.

Man kann die Software anhand von verschiedenen Qualitätsmerkmalen bewerten. Ein paar davon werden wir jetzt erklären.

### Innere und äußere Qualität

Eine Art um die Qualität von Softwaresystemen zu bewerten ist die Unterscheidung zwischen innerer und äußerer Qualität. Die innere Qualität beschreibt die Qualität der Software an sich. Die äußere Qualität beschreibt die Qualität der Software aus der Sicht des Nutzers. 

Die innere Qualität ist die Perspektive des Entwicklers. Sie beschreibt die Aspekte die für den Entwickler wichtig sind. Dazu gehören:

- Codequalität
- Wartbarkeit
- Erweiterbarkeit
- Testbarkeit
- Dokumentation
- Wiederverwendbarkeit
- Verständlichkeit
- Lesbarkeit
- Architektur

Die äußere Qualität ist die Perspektive des Nutzers. Also was will der Nutzer von der Software. Dazu gehören:

- Funktionalität
- Zuverlässigkeit
- Benutzbarkeit
- Effizienz
- Einfache Verwendung
- Bedienbarkeit
- Benutzerfreundlichkeit
- Fehlerfreiheit
- Sicherheit

### Qualitätsdreieck und Teufelsquadrat

Eine weitere Hilfe um Systeme zu bewerten ist das Qualitätsdreieck und das Teufelsquadrat. Das Qualitätsdreieck beschreibt die Beziehung zwischen den Qualitätsmerkmalen Funktionalität, Kosten und Zeit. Das Teufelsquadrat beschreibt die Beziehung zwischen den Qualitätsmerkmalen Funktionalität, Kosten, Zeit und Qualität.

Das Qualitätsdreieck kann wie folgt aussehen:

![:scale 80%](media/quali.png)

Das Teufelsquadrat kann wie folgt aussehen:

![:scale 60%](media/quad1.png)

Die schlechte Seite ist für gewöhnlich außen also mehr Kosten, weniger Qualität, etc. Die gute Seite ist innen. Ausgefüllt kann das Teufelsquadrat wie folgt aussehen:

![:scale 60%](media/quad2.png)

In dem Beispiel sieht man ein Projekt, in dem mehr Inhalt erwartet wird als eigentlich möglich ist. Das beeinflusst auch die anderen Faktoren. Die Qualität sinkt zum Beispiel.

## Qualitätsmodelle

Es gibt verschiedene Qualitätsmodelle die einem helfen können die Qualität von Softwaresystemen zu bewerten. Ein paar davon werden wir jetzt erklären.

### FCM Modelle

FCM steht für Factor-Criteria-Metric. Die Qualitätsmerkmale werden in Faktoren, Kriterien und Metriken unterteilt. 

**Faktoren** sind die verschiedenen Aspekte, oder Eigenschaften eines Softwaresystems, die auf irgendeine Weise die Qualität des Systems beeinflussen. Ein Beispiel für einen Faktor ist die Wartbarkeit. Die Wartbarkeit ist ein Faktor, weil sie die Qualität des Systems beeinflusst. Ein System, das gut wartbar ist, ist von besserer Qualität als ein System, das schlecht wartbar ist.

**Kriterien** sind Maßstäbe, oder Standards, mit denen man die faktoren selbst bewerten kann. Ein Kriterium für die Wartbarkeit ist zum Beispiel die Komplexität. Ein System, das eine geringe Komplexität hat, ist besser wartbar als ein System, das eine hohe Komplexität hat.

**Metriken** sind Messwerte mit denen man die Kriterien bewerten kann. Eine Metrik für die Komplexität ist zum Beispiel die Anzahl der Codezeilen. Ein System, das weniger Codezeilen hat, ist weniger komplex und deshalb besser wartbar als ein System, das mehr Codezeilen hat. Natürlich ist das nicht immer so, aber es ist ein guter Anhaltspunkt.

Diese drei Teile sind also eine Art Hierarchie. Die Faktoren sind die oberste Ebene, die Kriterien die mittlere und die Metriken die unterste. Hat man die Faktoren identifiziert, kann man als nächstes die Kriterien bestimmen und als letztes die Metriken. Hat man diese Punkte bestimmt kann man das System berwertet.

### ISO 25010

ISO 25010 ist ein Qualitätsmodell, dass sich speziell auf Softwareprodukte bezieht. Es ist ein sehr umfangreiches Modell, dass viele verschiedene Qualitätsmermale enthält. Auf der Abbildung sieht man die Oberkategorien und ihre einzelnen Unterkategorien.

![:scale 100%](media/iso.png)

### FURPS

FURPS ist ein weiteres Qualitätsmodell, dass bestimmte Qualitätsmerkmale definiert. Der Ausdruck FUPRS ist ein Akronym für:

- Functionality - Wie gut erfüllt das System seine Funktionen?
- Usability - Wie gut kann das System benutzt werden?
- Reliability - Wie zuverlässig ist das System?
- Performance - Wie gut ist die Performance des Systems?
- Supportability - Wie gut ist das System wartbar?


## Relevante Qualitätsmerkmale im Detail

### Complexity

- Unterscheidung zwischen inhärenter und unbeabsichtigter Komplexität

**Inhärente Komplexität:**

- Schwierigkeiten, die in einem System von Natur aus vorhanden sind
    - Können nicht vermieden werden, da sie in der Natur des Problems bereits vorhanden sind.
- Beispiel: Strukturelle Komplexität
    - Module, Klassen und Komponenten können die Komplexität eines Problems erhöhen, wenn diese untereinander interagieren

**Unbeabsichtigte Komplexität:**

- entsteht durch Entscheidungen, die den Code unnötig kompliziert machen
    - Übermäßige Abstraktionen, unnötige Designmuster, …
- Reduzierung der unbeabsichtigten Komplexität nötig
    - Einfachheit: Wenige Abstraktionsebenen
    - Klare Kommunikation
    - Refactoring: Refactoring des Codes kann Komplexität vermeiden



**Cynefin-Framework:**

- entwickelt von Dave Snowden
- soll helfen den Kontext von Problemen zu verstehen
- Vier Kontextbereiche:
- Einfach
    - Klare Ursache-Wirkungs-Beziehung
    - bewährte Lösungspraktiken kommen zum Einsatz
- Kompliziert
    - Komplexe, aber analysierbare Probleme
    - Fachwissen zum Lösen der Probleme benötigt
    - Expertenanalysen und Best-Practices kommen zum Einsatz
- Komplex
    - Keine vorhersehbare Lösung
    - Iteratives Vorgehen
- Chaotisch
    - Keine klare Ursache-Wirkungs-Beziehung
    - Sofortiges Handeln zum Lösen des Problems
    - Später: Verschieben in den Bereich “Komplex”
- Cynefin-Framework hilft bei der Entscheidung, wie ein Problem angegangen werden sollte



### Maintainability (Wartbarkeit)

- Bedeutung für Erfolg und Anpassungsfähigkeit der Software
- Erleichtert das Durchführen von Fehlerbehebungen, Änderungen, …
- Wartbare Systeme sind kosteneffizienter zu pflegen
- Elemente der Wartbarkeit
    - Klar strukturierter Code
    - Umfassende Dokumentation
    - Konsistente Architektur
- Verbesserung der Wartbarkeit
    - Refactoring
    - agiles Entwickeln


### Observability (Beobachtbarkeit)

- Verständnis des Systemverhaltens
    - Erkennen von Fehlern
    - Optimierung der Leistung
- Effiziente Fehlerdiagnose
    - Schnelle Identifikation von Problemen
- Zuverlässigkeit
    - Obervability stellt sicher, dass ein System zuverlässig läuft

Elemente von Observability:

- Logging
    - Aufzeichnung von relevanten Ereignissen im System
- Monitoring
    - Überwachen von Metriken und Leistungsindikatoren
    - “Echtzeit-Monitoring”
- Tracing



### Reliability (Zuverlässigkeit)

- Vorteile von Reliability
    - schafft Vertrauen bei Nutzern der Software
    - Störungsfreier Betrieb der Software ist sichergestellt
    - Kosteneffizient

Elemente von Reliability:

- Fehlertoleranz
    - Das System erbringt, trotz auftretender Fehler, akzeptable Leistung
- Wiederherstellbarkeit
    - Effizienz, mit der ein System nach einem Fehler wiederhergestellt werden kann.
- Stabilität
    - Wie stabil ist ein System?
    - Vorhersagbarkeit des Systemverhaltens

Best-Practises für Reliability:

- Redunzanz
    - Das Einbauen von Redundanz kann kritische System absichern.
- Monitoring
    - Systemmetriken werden durchgehend überwacht, um frühzeitig auf Fehler und Probleme reagieren zu können.
- Automatisierte Tests
    - Das System wird regelmäßig automatisiert getestet, um Probleme zu erkennen.



### Availability (Verfügbarkeit)

- Vorteile von Availability
    - Fördert eine positive Erfahrung des Nutzers, da er immer auf das System zugreifen kann.
    - Fördert Produktivität, z.B. in geschäftskritischen Anwendungen, die immer verfügbar seien müssen, damit ein reibungsloser Betrieb des Unternehmens gewährleistet werden kann.

Elemente der Avaibility:

- Lastverteilung
    - Verteilung von Lasten auf mehrere Server, damit Überlastungen minimiert werden können.
- Ausfallsicherheit
    - Schaffung von Strategien, mit denen man Ausfälle frühzeitig erkennen und dann bekämpfen kann.

Best-Practices für Availability:

- Monitoring
    - Kontinuierliche Überwachung von Systemmetriken, um frühzeitig auf potenzielle Probleme zu reagieren.
- Automatisierung von Wiederherstellungsprozessen
    - Automatisierte Prozesse zur schnellen Wiederherstellung nach einem Ausfall.
- Globale Verteilung
    - Globale Verteilung von Ressourcen, um auf geografisch verteilte Nutzer effizient reagieren zu können.



### Resilience (Widerstandsfähigkeit)

- Fähigkeit einer Software, sich nach einem Problem zu erholen und weiter zu funktionieren
- Umgang mit Problemen in der Software, ohne dass diese komplett abstürzt

Einige Aspekte:

- Fehlererkennung
    - Resiliente Software erkennt Fehler frühzeitig und kann angemessen darauf reagieren. Dies umfasst die Implementierung von Mechanismen zur Fehlererkennung, Protokollierung und Benachrichtigung.
- Fehlertoleranz
    - Ein resilientes System kann teilweise funktionsfähig bleiben, auch wenn Teile davon ausfallen. Dies kann durch redundante Systemkomponenten oder durch die Bereitstellung von alternativen Pfaden für die Ausführung von Aufgaben erreicht werden.
- Automatisiertes Testen
    - Durch gründliche und automatisierte Tests können Entwickler sicherstellen, dass ihre Software robust gegenüber Fehlern und unerwarteten Eingaben ist.
- Wiederherstellbarkeit
    - Resiliente Software kann sich selbst wiederherstellen, nachdem ein Fehler aufgetreten ist. Dies kann die automatische Wiederherstellung von Daten aus Backups oder das Zurücksetzen von Zuständen auf einen vorherigen stabilen Zustand umfassen.



### Performance

- Fähigkeit eines Systems, Ressourcen optimal zu nutzen, effektiv zu arbeiten und eine gute Benutzererfahrung zu bieten

Aspekte:

- Laufzeitgeschwindigkeit
    - Die Ausführungsgeschwindigkeit von Software ist ein entscheidender Faktor. Effizienter Code und Algorithmen tragen dazu bei, dass Anwendungen schnell und reaktionsschnell sind. Optimierungen können auf verschiedenen Ebenen vorgenommen werden, einschließlich des Algorithmusdesigns, der Datenstrukturen und des Quellcodes.
- Ressourcennutzung
    - Effiziente Ressourcennutzung ist entscheidend, um sicherzustellen, dass eine Anwendung nicht mehr Ressourcen (CPU, Speicher, Netzwerkbandbreite) verwendet, als notwendig ist. Dies verbessert nicht nur die Leistung, sondern trägt auch dazu bei, die Betriebskosten zu minimieren.
- Skalierbarkeit
    - Die Fähigkeit eines Systems, mit zunehmender Last umzugehen, ist von großer Bedeutung. Skalierbare Systeme können ihre Kapazität je nach Bedarf anpassen, sei es durch vertikale Skalierung (Hinzufügen von Ressourcen zu einer einzelnen Instanz) oder durch horizontale Skalierung (Hinzufügen von mehr Instanzen).
- Code-Optimierung
    - Gut geschriebener Code ist entscheidend für die Leistung. Dies beinhaltet das Vermeiden von ineffizienten Konstruktionen, das Minimieren von Schleifen, das intelligente Management von Ressourcen und die Verwendung von geeigneten Datenstrukturen.



## Metriken zur Messung von Softwarequalität

- Metriken werden in der Softwareentwicklung genutzt, um die Qualität von Software zu messen
- Verschiedene Arten von Metriken
    - Konventionelle Metriken: z.B. McCabe-Metrik
    - Objektorientierte Metriken: z.B. Lack of Cohesion Methods



### Konventionelle Metriken

- werden häufig zur Bewertung von Softwarekomplexität und -qualität verwendet

**McCabe-Metrik:**

- auch zyklomatische Komplexität genannt
- misst die Softwarekomplexität durch Analyse des Kontrollflussgraphen
    - Anzahl der linear unabhängigen Pfade im Programmcode beschreibt die Komplexität

Formel zur Berechnung der zyklomatischen Komplexität:

V(G) = E - N + 2P

Bedeutung:

- E: Anzahl der Kanten im Kontrollflussgraphen
- N: Anzahl der Knoten im Kontrollflussgraphen
- P: Anzahl der Zusammenhangskomponenten (oft als Anzahl der verbundenen Bereiche im Graphen interpretiert)

Allgemein gilt:

- V(G)≤10: Niedrige Komplexität, einfacher Code
- 10<*V*(*G*)≤20: Moderate Komplexität, durchschnittlicher Code.
- *V*(*G*)>20: Hohe Komplexität, möglicherweise schwer verständlicher Code.


**Beispiel:** 

```java
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, n):
        if n % i == 0:
            return False
    return True
```

Hier hat der Kontrollflussgraph drei Entscheidungspunkte (zwei Verzweigungen und eine Schleife). Die Anzahl der Kanten (E) beträgt 7, die Anzahl der Knoten (N) beträgt 6, und es gibt eine Zusammenhangskomponente (P=1). Setzen wir diese Werte in die Formel ein:

*V*(*G*)=7−6+2×1=3


### Objektorientierte Metriken

- eignen sich, um Aspekte von objektorientiertem Code zu bewerten

**Lack of Cohesion in Methods:**

- misst das Ausmaß der Kohäsion innerhalb einer Klasse
    - Kohäsion: Methoden in einer Klasse, die auf gemeinsame Daten zugreifen

Formel für Berechnung von LCOM:

LCOM = (m-p) / (p-1)

Mit:

- m: Anzahl der Methoden in der Klasse
- p: Anzahl der Attribute, die von mindestens einer Methode verwendet werden

- Niedriger LCOM-Wert bedeutet gute Kohäsion



**Beispiel:**

```java
class ExampleClass:
    def method1(self, a, b):
        return a + b

    def method2(self, c, d):
        return c * d

    def method3(self, e):
        print(e)
```



## Modellierung und Visualisierung von Softwaresystemen

**Descriptive-Modelling**

- Beschreibung von Verhalten und Struktur eines Systems
- keine expliziten Regeln oder Vorschriften
- Beispiele: UML-Diagramme, ER-Diagramme, Zustandsdiagramme

**Rule-Based-Modellung**

- Verwendung von Regeln, um die Struktur eines Systems zu modellieren
- Beispiele: Geschäftsregeln, Workflow-Modells, Regelbasierte Systeme



### UML (Unified Modelling Language)

- Modellierungssprache, um Systeme zu visualisieren und zu dokumentieren
- UML besteht aus vielen verschiedenen Diagrammtypen
    - diese decken verschiedene Aspekte des Systems ab
    

**Statische Diagrammtypen:**

- Klassendiagramme
    - Struktur des Systems: Klassen, Attribute, Methoden und Beziehungen zwischen verschiedenen Klassen
- Objektdiagramme
    - Momentaufnahme von Instanzen und Klassen in einem bestimmten Moment
- Komponentendiagramme
    - Zeigen physische Komponenten eines Systems und deren Abhängigkeiten

**Dynamische Diagrammtypen:**

- Zustandsdiagramme
    - beschreiben den Lebenszyklus eines Objekts und die Übergänge zwischen den Zuständen
- Sequenzdiagramme
    - Zeitliche Abfolge von Nachrichten zwischen Objekten und Klassen



**Zuordnung der UML-Diagrammtypen zu Phasen der Softwareentwicklung:**

1. Anforderungsanalyse und Spezifikation
    - Use-Case-Diagramme
        - Visualisieren Systemfunktionen
2. Entwurfsphase
    - Klassendiagramme
        - Zum Abbilden der statischen Struktur eines Systems
    - Sequenzdiagramme
        - Modellieren die Interaktionen zwischen Objekten
3. Implementierungsphase
    - Komponentendiagramme
        - Zeigen physische Komponenten des Systems
4. Testphase
    - Zustandsdiagramme
        - Testet den Lebenszyklus von Objekten und die Übergänge zwischen den Zuständen
    - Sequenzdiagramme
        - Kommunikation zwischen Objekten kann getestet werden



**Software-Architecture-Documentation**

Inhalt der Dokumentation:

- Einleitung und Ziele
    - Warum die Dokumentation?
    - Ziel der Architektur
- Kontext und Stakeholder
    - Systemkontext beschreiben
    - Wer sind die Stakeholder?
- Qualitätsziele
    - Leistung, Skalierbarkeit, Sicherheit, …
- Architektonische Entscheidungen
    - Wesentliche Architekturentscheidungen
- Datenmodell
- Laufzeitsicht
- Weitere individuelle Punkte

Tools für die Dokumentation:

- UML-Diagramme
- arc42
- andere Dokumentationswerkzeuge



**Softwaredokumentation mit arc42**

- Framework zur Softwaredokumentation

Struktur von arc42 (Gliedert sich in 12 Hauptkapitel auf):

1. Einleitung und Ziele
    - Beschreibung der Ziele und Intentionen der Architekturbeschreibung.
2. Rahmenbedingungen
    - Berücksichtigung von Umweltbedingungen, Stakeholder-Anforderungen, technischen und organisatorischen Rahmenbedingungen.
3. Lösungsstrategie
    - Darstellung der Architektur- und Designentscheidungen, die zur Lösung des Problems führen.
4. Grenzen
    - Definition der Systemgrenzen und Abgrenzung gegenüber anderen Systemen.
5. Qualitätsziele
    - Festlegung von Qualitätszielen und Bewertung, wie diese durch die Architektur erfüllt werden.
6. Bereiche und Verantwortlichkeiten
    - Aufteilung des Systems in Bereiche und Definition der Verantwortlichkeiten.
7. Bausteinsicht
    - Beschreibung der Struktur des Systems in Form von Bausteinen (Module, Komponenten) und deren Beziehungen.
8. Laufzeitsicht
    - Darstellung der dynamischen Aspekte des Systems, insbesondere Interaktionen zwischen Bausteinen zur Laufzeit.
9. Verteilungssicht
    - Falls relevant, Beschreibung der Verteilung von Bausteinen auf physische Hardware oder Softwareumgebungen.
10. Datenperspektive
    - Beschreibung der Datenstrukturen und -flüsse im System.
11. Zuschnitt und Implementierung
    - Diskussion von Entwicklungs- und Umsetzungsaspekten.
12. Qualitätsanforderungen und Tests
    - Verbindung von Qualitätszielen zu Teststrategien und Maßnahmen zur Qualitätssicherung.

# Abbildungen

- https://fluxum.substack.com/p/warum-der-unterschied-zwischen-komplex#:~:text=Komplizierte%20Systeme%20k%C3%B6nnen%20analysiert%20werden,die%20Faktoren%20sich%20gegenseitig%20beeinflussen

- https://www.riseup.ai/de/blog/adaptives-machinelles-lernen

- https://t2informatik.de/wissen-kompakt/systemkontext/#:~:text=Systemkontext%20Definition,einer%20Entwicklung%20zu%20beachten%20sind

- https://digitaleneuordnung.de/blog/system-thinking/

- https://www.eveline-lemke.de/2018/08/systems-thinking/

- https://www.studysmarter.de/schule/psychologie/hauptstroemungen-der-psychologie/emergenz/

- https://medium.com/disruptive-design/tools-for-systems-thinkers-the-6-fundamental-concepts-of-systems-thinking-379cdac3dc6a

# Referenzen

- https://fluxum.substack.com/p/warum-der-unterschied-zwischen-komplex#:~:text=Komplizierte%20Systeme%20k%C3%B6nnen%20analysiert%20werden,die%20Faktoren%20sich%20gegenseitig%20beeinflussen

- https://www.riseup.ai/de/blog/adaptives-machinelles-lernen

- https://t2informatik.de/wissen-kompakt/systemkontext/#:~:text=Systemkontext%20Definition,einer%20Entwicklung%20zu%20beachten%20sind

- https://digitaleneuordnung.de/blog/system-thinking/

- https://www.eveline-lemke.de/2018/08/systems-thinking/

- https://www.studysmarter.de/schule/psychologie/hauptstroemungen-der-psychologie/emergenz/

- https://medium.com/disruptive-design/tools-for-systems-thinkers-the-6-fundamental-concepts-of-systems-thinking-379cdac3dc6a

- https://interim-cio.biz/artikel-projektsteuerung-teufelsquadrat#:~:text=Das%20Teufelsquadrat%20ist%20ein%20anschauliches,Dreieck%20macht%20das%20Modell%20unpraktikabel

- [https://www.objectsystems.de/die-komplexitaet-von-softwaresystemen.html](https://www.objectsystems.de/die-komplexitaet-von-softwaresystemen.html) [letzte Einsicht: 29.11.23]

- [https://www.praxisframework.org/de/knowledge/complexity](https://www.praxisframework.org/de/knowledge/complexity) [letzte Einsicht: 29.11.23]

- [https://de.wikipedia.org/wiki/Cynefin-Framework](https://de.wikipedia.org/wiki/Cynefin-Framework) [letzte Einsicht: 29.11.23]

- [https://de.wikipedia.org/wiki/Wartbarkeit](https://de.wikipedia.org/wiki/Wartbarkeit) [letzte Einsicht: 30.11.23]

- [https://www.ibm.com/de-de/topics/observability](https://www.ibm.com/de-de/topics/observability) [letzte Einsicht: 30.11.23]

- [https://www.dev-insider.de/was-ist-software-zuverlaessigkeit-a-820767/](https://www.dev-insider.de/was-ist-software-zuverlaessigkeit-a-820767/) [letzte Einsicht: 30.11.23]

- [https://en.wikipedia.org/wiki/High_availability_software](https://en.wikipedia.org/wiki/High_availability_software) [letzte Einsicht: 30.11.23]

- [https://www.bmc.com/blogs/reliability-vs-availability/](https://www.bmc.com/blogs/reliability-vs-availability/) [letzte Einsicht: 30.11.23]

- [https://www.iks.fraunhofer.de/en/research/resilient-software-systems.html](https://www.iks.fraunhofer.de/en/research/resilient-software-systems.html) [letzte Einsicht: 30.11.23]

- [https://www.dev-insider.de/performance-optimierung-softwareentwicklung-datenbanken-a-ac5fb659720503caf84efd7c6ee0d7bb/](https://www.dev-insider.de/performance-optimierung-softwareentwicklung-datenbanken-a-ac5fb659720503caf84efd7c6ee0d7bb/) [letzte Einsicht: 30.11.23]

- [https://www.dev-insider.de/was-ist-zyklomatische-komplexitaet-a-7fa40c670052685ff1c56d8169a79481/](https://www.dev-insider.de/was-ist-zyklomatische-komplexitaet-a-7fa40c670052685ff1c56d8169a79481/) [letzte Einsicht: 1.12.23]

- Beispiele erstellt von Chat-GPT3.5: https://www.chat.openai.com

- [https://blog.ndepend.com/lack-of-cohesion-methods/](https://blog.ndepend.com/lack-of-cohesion-methods/) [letzte Einsicht: 1.12.23]

- [https://www.infrasoft.at/images/downloads/uebersicht_der_uml_diagramme.pdf](https://www.infrasoft.at/images/downloads/uebersicht_der_uml_diagramme.pdf) [letzte Einsicht: 1.12.23]

- [https://www.arc42.de/](https://www.arc42.de/) [letzte Einsicht: 1.12.23]

- [https://www.innoq.com/en/blog/2022/08/brief-introduction-to-arc42/](https://www.innoq.com/en/blog/2022/08/brief-introduction-to-arc42/) [letzte Einsicht: 1.12.23]